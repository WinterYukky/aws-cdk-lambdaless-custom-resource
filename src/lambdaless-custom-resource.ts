import * as cdk from 'aws-cdk-lib';
import { Authorization, Connection } from 'aws-cdk-lib/aws-events';
import * as iam from 'aws-cdk-lib/aws-iam';
import { CfnPipe } from 'aws-cdk-lib/aws-pipes';
import { CfnSubscription, Topic } from 'aws-cdk-lib/aws-sns';
import { SqsSubscription } from 'aws-cdk-lib/aws-sns-subscriptions';
import { Queue } from 'aws-cdk-lib/aws-sqs';
import {
  Choice,
  Condition,
  DefinitionBody,
  IStateMachine,
  Pass,
  QueryLanguage,
  StateMachine,
  StateMachineType,
  TaskInput,
  Wait,
  WaitTime,
} from 'aws-cdk-lib/aws-stepfunctions';
import {
  CallAwsService,
  CallAwsServiceJsonataProps,
  CallAwsServiceProps,
  HttpInvoke,
} from 'aws-cdk-lib/aws-stepfunctions-tasks';
import { Construct } from 'constructs';

interface LambdalessProviderProps {
  // readonly workflow: IChainable;
}

// Architecture: SNS -> SQS -> EventBridge Pipes -> Express State Machine -> User-defined Standard State Machine
//
// Intentionally no DLQ (infinite retries) to handle long-running workflows:
// - Express State Machine times out after 5 minutes, but user-defined Standard SFn may take longer
// - On timeout, Pipes treats it as a failure and retries the SQS message
// - On retry, describeExecution finds the previous execution and responds to CloudFormation if completed
// - Using RequestId as execution name ensures idempotency
// - SQS default retention (4 days) is well beyond CloudFormation's max timeout (1 hour)
class LambdalessProvider extends Construct {
  private readonly subscription: cdk.aws_sns.Subscription;
  readonly stateMachine: cdk.aws_stepfunctions.StateMachine;

  constructor(scope: Construct, id: string, _props: LambdalessProviderProps) {
    super(scope, id);

    const topic = new Topic(this, 'Topic');
    const queue = new Queue(this, 'Queue');
    this.subscription = topic.addSubscription(new SqsSubscription(queue));
    const stateMachine = this.createStateMachine();

    // // To ensure that resources can be replaced without recreation when the Pipes alpha module becomes stable,
    // // avoid creating CfnPipe and Role resources directly under the construct.
    const pipe = new Construct(this, 'Pipe');
    {
      const pipeRole = new iam.Role(pipe, 'Role', {
        assumedBy: new iam.ServicePrincipal('pipes.amazonaws.com'),
      });
      const cfnPipe = new CfnPipe(pipe, 'Resource', {
        source: queue.queueArn,
        target: stateMachine.stateMachineArn,
        sourceParameters: {
          sqsQueueParameters: {
            batchSize: 1,
          },
        },
        targetParameters: {
          inputTemplate: `<$.body.Message>`,
          stepFunctionStateMachineParameters: {
            invocationType: 'REQUEST_RESPONSE',
          },
        },
        roleArn: pipeRole.roleArn,
        description: 'Auto generated by AWS CDK Custom Resource',
      });
      cfnPipe.node.addDependency(pipeRole);
      queue.grantConsumeMessages(pipeRole);
      stateMachine.grantStartSyncExecution(pipeRole);
    }

    this.subscription.node.addDependency(pipe);
    this.stateMachine = stateMachine;
  }

  get serviceToken() {
    const stack = cdk.Stack.of(this);
    const subscriptionArn = stack.splitArn(
      (this.subscription.node.defaultChild as CfnSubscription).attrArn,
      cdk.ArnFormat.COLON_RESOURCE_NAME,
    );
    return stack.formatArn({
      partition: subscriptionArn.partition,
      account: subscriptionArn.account,
      region: subscriptionArn.region,
      service: subscriptionArn.service,
      resource: subscriptionArn.resource,
    });
  }

  private createStateMachine() {
    const connection = new Connection(this, 'Connection', {
      authorization: Authorization.apiKey(
        'dummy',
        cdk.SecretValue.unsafePlainText('dummy'),
      ),
    });
    const init = Pass.jsonata(this, 'Initialize', {
      assign: {
        ExecutionArn: `{% $replace($states.input.ResourceProperties.stateMachineArn, 'stateMachine', 'execution') & ':' & $states.input.RequestId %}`,
        RequestType: `{% $states.input.RequestType %}`,
        ResponseURL: `{% $states.input.ResponseURL %}`,
        StackId: `{% $states.input.StackId %}`,
        RequestId: `{% $states.input.RequestId %}`,
        ResourceType: `{% $states.input.ResourceType %}`,
        LogicalResourceId: `{% $states.input.LogicalResourceId %}`,
        PhysicalResourceId: `{% $exists($states.input.PhysicalResourceId) ? $states.input.PhysicalResourceId : null %}`,
        ResourceProperties: `{% $states.input.ResourceProperties %}`,
        OldResourceProperties: `{% $exists($states.input.OldResourceProperties) ? $states.input.OldResourceProperties : null %}`,
      },
    });
    const stillRunning = Wait.jsonata(this, 'Still Running', {
      time: WaitTime.duration(cdk.Duration.seconds(1)),
    });
    const startExecution = ConditionalCallAwsService.jsonata(
      this,
      'Start Execution',
      {
        action: 'startExecution',
        service: 'sfn',
        iamResources: ['*'],
        iamAction: 'states:startExecution',
        parameters: {
          Name: '{% $RequestId %}',
          Input: {
            RequestType: `{% $RequestType %}`,
            StackId: `{% $StackId %}`,
            RequestId: `{% $RequestId %}`,
            ResourceType: `{% $ResourceType %}`,
            LogicalResourceId: `{% $LogicalResourceId %}`,
            PhysicalResourceId: `{% $PhysicalResourceId %}`,
            ResourceProperties: `{% $ResourceProperties %}`,
            OldResourceProperties: `{% $OldResourceProperties %}`,
          },
          StateMachineArn: '{% $ResourceProperties.stateMachineArn %}',
        },
      },
    ).next(stillRunning);

    const describeExecution = ConditionalCallAwsService.jsonata(
      this,
      'Describe Execution',
      {
        action: 'describeExecution',
        service: 'sfn',
        iamResources: ['*'],
        parameters: {
          ExecutionArn: '{% $ExecutionArn %}',
          IncludedData: 'ALL_DATA',
        },
      },
    ).addCatch(startExecution);
    const cfnResponse = HttpInvoke.jsonata(this, 'Response to CloudFormation', {
      apiRoot: `{% $match($ResponseURL, /(https://[^/]+)\\/(.*)\\?/).groups[0] %}`,
      apiEndpoint: TaskInput.fromText(
        `{% $match($ResponseURL, /(https://[^/]+)\\/(.*)\\?/).groups[1] ~> $decodeUrlComponent() %}`,
      ),
      method: TaskInput.fromText('PUT'),
      connection,
      body: TaskInput.fromObject({
        Status: `{% $exists($states.input.Status) ? $states.input.Status : 'SUCCESS' %}`,
        StackId: '{% $StackId %}',
        RequestId: '{% $RequestId %}',
        LogicalResourceId: '{% $LogicalResourceId %}',
        Data: `{% (
            $deepSpread := function($value, $path, $arr) {(
                $arr := $arr ? $arr : [];
                $t := $type($value);
                $result := 
                $t = "object" ? $each($value, function($v, $k){
                    $deepSpread($v, $path ? $path & "." & $k : $k, $arr)
                }) : 
                $t = "array" ? $map($value, function($el, $index){
                    $deepSpread($el, $path ? $path & "." & $string($index) : $string($index), $arr)
                }) :
                {
                    $path: $string($value)
                };
                $append($arr, $result) ~> $merge
            )};
            $exists($states.input.Data) ? $deepSpread($states.input.Data) : {}
            ) %}`,
        NoEcho:
          '{% $exists($states.input.NoEcho) ? $states.input.NoEcho : false %}',
        PhysicalResourceId:
          '{% $exists($states.input.PhysicalResourceId) ? $states.input.PhysicalResourceId : $RequestId %}',
        Reason:
          "{% $exists($states.input.Reason) ? $states.input.Reason : '' %}",
      }),
      queryStringParameters: TaskInput.fromText(
        "{% $ResponseURL ~> $substringAfter('?') ~> $split('&') ~> $map(function($v) {( $kv := $split($v, '='); {$kv[0]: $decodeUrlComponent($kv[1])} )}) ~> $merge %}",
      ),
    });
    stillRunning.next(describeExecution);
    const isFinished = Choice.jsonata(this, 'Is finished?')
      .when(
        Condition.jsonata("{% $states.input.Status = 'RUNNING' %}"),
        stillRunning,
      )
      .when(
        Condition.jsonata("{% $states.input.Status = 'SUCCEEDED' %}"),
        cfnResponse,
        {
          outputs: '{% $parse($states.input.Output) %}',
        },
      )
      .otherwise(
        Pass.jsonata(this, 'Given workflow was failed', {
          outputs: {
            Status: 'FAILED',
            Reason: "{% $states.input.Error & ': ' & $states.input.Cause %}",
          },
        }).next(cfnResponse),
      );
    return new StateMachine(this, 'StateMachine', {
      stateMachineType: StateMachineType.EXPRESS,
      queryLanguage: QueryLanguage.JSONATA,
      definitionBody: DefinitionBody.fromChainable(
        init.next(describeExecution).next(isFinished),
      ),
    });
  }
}

/**
 * Properties to provide a Lambdaless custom resource
 */
export interface LambdalessCustomResourceProps {
  readonly stateMachine: IStateMachine;
  /**
   * The maximum time that can elapse before a custom resource operation times out.
   *
   * The value must be between 1 second and 3600 seconds.
   *
   * Maps to [ServiceTimeout](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloudformation-customresource.html#cfn-cloudformation-customresource-servicetimeout) property for the `AWS::CloudFormation::CustomResource` resource
   *
   * A token can be specified for this property, but it must be specified with `Duration.seconds()`.
   *
   * @example
   * const stack = new Stack();
   * const durToken = new CfnParameter(stack, 'MyParameter', {
   *   type: 'Number',
   *   default: 60,
   * });
   * new CustomResource(stack, 'MyCustomResource', {
   *   serviceToken: 'MyServiceToken',
   *   serviceTimeout: Duration.seconds(durToken.valueAsNumber),
   * });
   *
   * @default Duration.seconds(3600)
   */
  readonly serviceTimeout?: cdk.Duration;
  /**
   * Properties to pass to the Lambda
   *
   * Values in this `properties` dictionary can possibly overwrite other values in `CustomResourceProps`
   * E.g. `ServiceToken` and `ServiceTimeout`
   * It is recommended to avoid using same keys that exist in `CustomResourceProps`
   *
   * @default - No properties.
   */
  readonly properties?: {
    [key: string]: any;
  };
  /**
   * For custom resources, you can specify AWS::CloudFormation::CustomResource
   * (the default) as the resource type, or you can specify your own resource
   * type name. For example, you can use "Custom::MyCustomResourceTypeName".
   *
   * Custom resource type names must begin with "Custom::" and can include
   * alphanumeric characters and the following characters: _@-. You can specify
   * a custom resource type name up to a maximum length of 60 characters. You
   * cannot change the type during an update.
   *
   * Using your own resource type names helps you quickly differentiate the
   * types of custom resources in your stack. For example, if you had two custom
   * resources that conduct two different ping tests, you could name their type
   * as Custom::PingTester to make them easily identifiable as ping testers
   * (instead of using AWS::CloudFormation::CustomResource).
   *
   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cfn-customresource.html#aws-cfn-resource-type-name
   *
   * @default - AWS::CloudFormation::CustomResource
   */
  readonly resourceType?: string;
  /**
   * The policy to apply when this resource is removed from the application.
   *
   * @default cdk.RemovalPolicy.Destroy
   */
  readonly removalPolicy?: cdk.RemovalPolicy;
  /**
   * Convert all property keys to pascal case.
   *
   * @default false
   */
  readonly pascalCaseProperties?: boolean;
}

export class LambdalessCustomResource extends Construct {
  private readonly resource: cdk.CustomResource;
  readonly ref: string;
  constructor(
    scope: Construct,
    id: string,
    props: LambdalessCustomResourceProps,
  ) {
    super(scope, id);

    const stack = cdk.Stack.of(this);
    const framework =
      (stack.node.tryFindChild('LambdalessProvider') as LambdalessProvider) ??
      new LambdalessProvider(stack, 'LambdalessProvider', {});
    this.resource = new cdk.CustomResource(this, 'Resource', {
      ...props,
      serviceToken: framework.serviceToken,
      properties: {
        ...props.properties,
        stateMachineArn: props.stateMachine.stateMachineArn,
      },
    });
    const policy = new iam.Policy(this, 'Policy');
    props.stateMachine.grantStartExecution(policy);
    framework.stateMachine.role.attachInlinePolicy(policy);
    this.resource.node.addDependency(policy);
    this.ref = this.resource.ref;
  }
  /**
   * Returns the value of an attribute of the custom resource of an arbitrary
   * type. Attributes are returned from the custom resource provider through the
   * `Data` map where the key is the attribute name.
   *
   * @param attributeName the name of the attribute
   * @returns a token for `Fn::GetAtt`. Use `Token.asXxx` to encode the returned `Reference` as a specific type or
   * use the convenience `getAttString` for string attributes.
   */
  getAtt(attributeName: string): cdk.Reference {
    return this.resource.getAtt(attributeName);
  }
  /**
   * Returns the value of an attribute of the custom resource of type string.
   * Attributes are returned from the custom resource provider through the
   * `Data` map where the key is the attribute name.
   *
   * @param attributeName the name of the attribute
   * @returns a token for `Fn::GetAtt` encoded as a string.
   */
  getAttString(attributeName: string): string {
    return this.resource.getAttString(attributeName);
  }
}

interface ConditionalCallAwsServiceProps extends CallAwsServiceProps {
  iamConditions?: Record<string, iam.Condition>;
}
interface ConditionalCallAwsServiceJsonataProps extends CallAwsServiceJsonataProps {
  iamConditions?: Record<string, iam.Condition>;
}
class ConditionalCallAwsService extends CallAwsService {
  /**
   * A StepFunctions task using JSONata to call an AWS service API
   */
  public static jsonata(
    scope: Construct,
    id: string,
    props: ConditionalCallAwsServiceJsonataProps,
  ) {
    return new ConditionalCallAwsService(scope, id, {
      ...props,
      queryLanguage: QueryLanguage.JSONATA,
    });
  }
  constructor(
    scope: Construct,
    id: string,
    props: ConditionalCallAwsServiceProps,
  ) {
    super(scope, id, props);
    this.taskPolicies![0].addConditions(props.iamConditions ?? {});
  }
}
